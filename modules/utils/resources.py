import os
from importlib import resources as resources
from importlib.abc import Traversable
from io import TextIOWrapper
from typing import Self, Iterator


class FileNotOpenError(Exception):
    pass


class Resource:
    """
    Opens a read-only local resource located in the local /resources module.
    The resource will be automatically found based on its filename.
    Only usabel with a context manager.

    If there's a filename conflict, for example there are files on different
    levels of directories with the same filename, in order to avoid conflicts,
    use the "module" parameter to specify the relative path from the top-level
    /resources folder.
    """

    def __init__(self, fname: str, module: str = "", binary: bool = False, **kwargs):
        """
        :param fname: Name of the file to open.
        :param module: The directory filter. Specify in "import" style, for example: "dir.subdir"
        :param binary: Whether to open the file in binary mode. Defaults to False
        :param kwargs: Kwargs to pass to file.open(mode, **kwargs)
        """

        self.fname = fname
        self.path = module
        self.bmode = binary
        # noinspection PyTypeChecker
        self.file_descriptor: TextIOWrapper = None
        self.kwargs = kwargs

    def __enter__(self) -> Self:
        directory_specifier = self.path.split(".") if self.path else None

        toplevel_resources_module = resources.files('resources')
        for resource in Resource.iterate_directory(toplevel_resources_module):
            if resource.name == self.fname:
                # directory filter
                if directory_specifier:
                    full_path = str(resource).split(os.sep)
                    resource_contents_index = full_path.index("resources") + 1  # shift to the right
                    relative_path = full_path[resource_contents_index:-1]
                    for specified_dir, relative_dir in zip(directory_specifier, relative_path):
                        if specified_dir != relative_dir:
                            continue
                self.file_descriptor = resource.open("rb" if self.bmode else "r", **self.kwargs)
                break

        if not self.file_descriptor:
            raise FileNotFoundError

        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file_descriptor is None:
            raise RuntimeError("self.file_descriptor is none in __exit__?!")

        if not self.file_descriptor.closed:
            self.file_descriptor.close()

        self.file_descriptor = None

    @property
    def contents(self) -> TextIOWrapper:
        """
        :raises FileNotOpenError: If the file is not open, raise a FileNotOpenError
        """
        if self.file_descriptor is None:
            raise FileNotOpenError()

        # FIXME: this is hacky; it's better to just expose the methods rather than the entire object
        #  however I'm limited by the technology of my time (meaning, I just don't know how to do it)
        return self.file_descriptor

    @staticmethod
    def iterate_directory(directory: Traversable) -> Iterator[Traversable]:
        for file in directory.iterdir():
            # ignore module definition file
            if file.name == "__init__.py":
                continue

            if file.is_dir():
                # ignore autogenerated python cache directory
                if file.name == "__pycache__":
                    continue
                for resource in Resource.iterate_directory(file):
                    yield resource
                continue

            yield file

        # prevent StopIteration
        return
