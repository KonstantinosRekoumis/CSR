import os
from importlib import resources as resources
from importlib.resources.abc import Traversable
from io import TextIOWrapper
from typing import Self, Iterator


class FileNotOpenError(Exception):
    pass


class Resource:
    """
    Opens a read-only local resource located in the local /resources module.
    The resource will be automatically found based on its filename.
    Usable with a context manager.
    """

    def __init__(self, *path: str, binary: bool = False, **kwargs):
        """
        :param fname: Name of the file to open.
        :param module: The directory filter. Specify in "import" style, for example: "dir.subdir"
        :param binary: Whether to open the file in binary mode. Defaults to False
        :param kwargs: Kwargs to pass to file.open(mode, **kwargs)
        """

        self.path = list(path)
        self.bmode = binary
        # noinspection PyTypeChecker
        self.file_descriptor: TextIOWrapper = None
        # noinspection PyTypeChecker
        self.resource: Traversable = None

        self.kwargs = kwargs

    def __enter__(self) -> Self:
        self.open()

        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file_descriptor is None:
            raise RuntimeError("self.file_descriptor is none in __exit__?!")

        self.close()

    def open(self):
        self.__cache_resource()
        self.file_descriptor = self.resource.open("rb" if self.bmode else "r", **self.kwargs)

    def close(self):
        if not self.file_descriptor.closed:
            self.file_descriptor.close()

        self.file_descriptor = None

    def is_closed(self) -> bool:
        return self.file_descriptor is None or self.file_descriptor.closed

    @property
    def handle(self) -> TextIOWrapper:
        """
        Opens the file, if it isn't already, and returns the file handle. Make sure to close after using.
        :raises FileNotOpenError: If the file is not open, raise a FileNotOpenError
        """
        if self.is_closed():
            self.open()

        return self.file_descriptor

    @property
    def absolute_path(self) -> str:
        self.__cache_resource()

        return str(self.resource)

    def __cache_resource(self):
        if self.resource is not None:
            return

        toplevel_resources_module = resources.files('resources')
        for resource in Resource.iterate_directory(toplevel_resources_module):
            if resource.name == self.path[-1]:
                # directory filter
                full_path = str(resource).split(os.sep)
                resource_contents_index = full_path.index("resources") + 1  # shift to the right
                relative_path = full_path[resource_contents_index:]

                if len(self.path) != len(relative_path):
                    continue

                for specified_dir, relative_dir in zip(self.path, relative_path):
                    if specified_dir != relative_dir:
                        continue
                self.resource = resource
                return

        raise FileNotFoundError

    @staticmethod
    def iterate_directory(directory: Traversable) -> Iterator[Traversable]:
        for file in directory.iterdir():
            # ignore module definition file
            if file.name == "__init__.py":
                continue

            if file.is_dir():
                # ignore autogenerated python cache directory
                if file.name == "__pycache__":
                    continue
                for resource in Resource.iterate_directory(file):
                    yield resource
                continue

            yield file

        # prevent StopIteration
        return


if __name__ == "__main__":
    with Resource("ui", "subui", "geom_dialog.ui") as r:
        print(r)
        print(r.absolute_path)
        print(r.handle)
